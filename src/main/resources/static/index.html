<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Spring AI ElevenLabs Streaming TTS Test</title>

    <style>
        body { font-family: Arial, sans-serif; max-width: 1000px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; }
        .container { background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #333; text-align: center; }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input, textarea, select { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
        textarea { height: 100px; resize: vertical; }
        button { background-color: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; display: block; margin: 20px auto; min-width: 200px; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .audio-section { margin-top: 30px; text-align: center; }
        audio { width: 100%; margin-top: 10px; }
        .log { background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 4px; padding: 15px; margin-top: 20px; max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px; }
        .error { color: #dc3545; } .success { color: #28a745; } .info { color: #17a2b8; } .warning { color: #ffc107; }
        .streaming-data { background-color: #2c3e50; color: #ecf0f1; border: 1px solid #34495e; border-radius: 4px; padding: 15px; margin-top: 20px; max-height: 300px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 11px; white-space: pre-wrap; }
        .progress-bar { width: 100%; height: 20px; background-color: #e9ecef; border-radius: 10px; margin: 10px 0; overflow: hidden; }
        .progress-fill { height: 100%; background-color: #007bff; width: 0%; transition: width 0.3s ease; }
        .stats { display: flex; justify-content: space-around; margin: 10px 0; font-size: 14px; flex-wrap: wrap; gap: 10px; }
        .stat-item { text-align: center; flex: 1; min-width: 120px; }
        .stat-value { font-weight: bold; font-size: 18px; color: #007bff; }
        .form-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; }
        @media (max-width: 768px) {
            .form-grid { grid-template-columns: 1fr; }
            .stats { flex-direction: column; }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>ðŸŽ¤ Spring AI ElevenLabs Streaming TTS Test</h1>

    <form id="ttsForm">
        <div class="form-group">
            <label for="text">Text to Convert to Speech:</label>
            <textarea id="text" name="text" placeholder="Enter the text you want to convert to speech..." required>Hello! This is a real-time text-to-speech streaming demonstration. You should start hearing this audio as it's being generated by the ElevenLabs API through Spring AI framework.</textarea>
        </div>

        <div class="form-group">
            <label for="voiceId">Voice ID:</label>
            <select id="voiceId" name="voiceId">
                <option value="21m00Tcm4TlvDq8ikWAM">Rachel (Female, American)</option>
                <option value="AZnzlk1XvdvUeBnXmlld">Domi (Female, American)</option>
                <option value="EXAVITQu4vr4xnSDxMaL">Bella (Female, American)</option>
                <option value="ErXwobaYiN019PkySvjV">Antoni (Male, American)</option>
                <option value="VR6AewLTigWG4xSOukaG">Arnold (Male, American)</option>
                <option value="pNInz6obpgDQGcFmaJgB" selected>Adam (Male, American)</option>
            </select>
        </div>

        <div class="form-grid">
            <div class="form-group">
                <label for="stability">Stability (0.0 - 1.0):</label>
                <input type="number" id="stability" name="stability" min="0" max="1" step="0.05" value="0.75">
            </div>

            <div class="form-group">
                <label for="similarityBoost">Similarity Boost (0.0 - 1.0):</label>
                <input type="number" id="similarityBoost" name="similarityBoost" min="0" max="1" step="0.05" value="0.75">
            </div>

            <div class="form-group">
                <label for="style">Style (0.0 - 1.0):</label>
                <input type="number" id="style" name="style" min="0" max="1" step="0.05" value="0.0">
            </div>

            <div class="form-group">
                <label for="useSpeakerBoost">Use Speaker Boost:</label>
                <select id="useSpeakerBoost" name="useSpeakerBoost">
                    <option value="true" selected>Yes</option>
                    <option value="false">No</option>
                </select>
            </div>

            <div class="form-group">
                <label for="speed">Speed (0.25 - 4.0):</label>
                <input type="number" id="speed" name="speed" min="0.25" max="4.0" step="0.1" value="1.0">
            </div>
        </div>

        <button type="submit" id="generateBtn">ðŸŽµ Generate Streaming Speech</button>
    </form>

    <div class="progress-section" style="display: none;">
        <h3>Streaming Progress:</h3>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="bytesReceived">0</div>
                <div>Bytes Received</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="chunksReceived">0</div>
                <div>Chunks Received</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="timeElapsed">0s</div>
                <div>Time Elapsed</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="avgSpeed">0</div>
                <div>KB/s</div>
            </div>
        </div>
    </div>

    <div class="audio-section">
        <h3>Generated Audio:</h3>
        <audio id="audioPlayer" controls style="display: none;">Your browser does not support the audio element.</audio>
        <p id="audioStatus">Fill out the form above and click "Generate Streaming Speech" to create audio</p>
    </div>

    <div class="streaming-section" style="display: none;">
        <h3>Streaming Data:</h3>
        <div class="streaming-data" id="streamingData">Waiting for streaming data...</div>
    </div>

    <div class="log" id="logArea"><strong>Console Log:</strong><br>Ready to generate streaming speech...</div>
</div>

<script>
    // ===== DOM refs =====
    const form = document.getElementById('ttsForm');
    const generateBtn = document.getElementById('generateBtn');
    const audioPlayer = document.getElementById('audioPlayer');
    const audioStatus = document.getElementById('audioStatus');
    const logArea = document.getElementById('logArea');
    const streamingData = document.getElementById('streamingData');
    const progressSection = document.querySelector('.progress-section');
    const progressFill = document.getElementById('progressFill');
    const bytesReceived = document.getElementById('bytesReceived');
    const chunksReceived = document.getElementById('chunksReceived');
    const timeElapsed = document.getElementById('timeElapsed');
    const avgSpeed = document.getElementById('avgSpeed');
    const streamingSection = document.querySelector('.streaming-section');

    // ===== Globals =====
    let startTime;
    let totalBytes = 0;
    let chunkCount = 0;
    let currentAbort = null;
    let mseInUse = false;
    const MIME = 'audio/mpeg'; // Backend outputs MP3

    // ===== Utils =====
    function addLog(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const cls = {error:'error',success:'success',warning:'warning',info:'info'}[type] || 'info';
        logArea.innerHTML += `<br><span class="${cls}">[${timestamp}] ${message}</span>`;
        logArea.scrollTop = logArea.scrollHeight;
        console.log(`[${timestamp}] ${message}`);
    }

    function updateStreamingData(text) {
        streamingData.textContent += text;
        streamingData.scrollTop = streamingData.scrollHeight;
    }

    function updateProgress(bytes, chunks) {
        totalBytes = bytes;
        chunkCount = chunks;
        bytesReceived.textContent = bytes.toLocaleString();
        chunksReceived.textContent = chunks;
        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
        timeElapsed.textContent = `${elapsed}s`;

        // Calculate speed in KB/s
        const speed = elapsed > 0 ? ((bytes / 1024) / parseFloat(elapsed)).toFixed(1) : 0;
        avgSpeed.textContent = speed;

        // Dynamic progress bar (estimate based on text length)
        const textLength = document.getElementById('text').value.length;
        const estimatedTotalBytes = textLength * 800; // Rough estimate: ~800 bytes per character for audio
        const progress = Math.min((bytes / estimatedTotalBytes) * 100, 100);
        progressFill.style.width = `${progress}%`;
    }

    function hexAsciiPreview(uint8, maxBytes = 64) {
        const slice = uint8.slice(0, Math.min(uint8.length, maxBytes));
        const hex = Array.from(slice).map(b => b.toString(16).padStart(2,'0')).join(' ');
        const ascii = Array.from(slice).map(b => (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.').join('');
        return { hex, ascii, shown: slice.length };
    }

    function createSafeCopy(u8) {
        return u8.buffer.slice(u8.byteOffset, u8.byteOffset + u8.byteLength);
    }

    function getFormData() {
        return {
            text: document.getElementById('text').value,
            voiceId: document.getElementById('voiceId').value,
            stability: parseFloat(document.getElementById('stability').value),
            similarityBoost: parseFloat(document.getElementById('similarityBoost').value),
            style: parseFloat(document.getElementById('style').value),
            useSpeakerBoost: document.getElementById('useSpeakerBoost').value === 'true',
            speed: parseFloat(document.getElementById('speed').value)
        };
    }

    function getMimeType() {
        return 'audio/mpeg'; // Backend always outputs MP3
    }

    // ===== Streaming player (MSE) =====
    async function playStreamWithMSE(response, mimeType) {
        return new Promise((resolve, reject) => {
            const mediaSource = new MediaSource();
            mseInUse = true;
            audioPlayer.src = URL.createObjectURL(mediaSource);
            audioPlayer.style.display = 'block';

            mediaSource.addEventListener('sourceopen', async () => {
                addLog('MediaSource opened. Initializing SourceBuffer...', 'info');
                let sourceBuffer;
                try {
                    sourceBuffer = mediaSource.addSourceBuffer(mimeType);
                } catch (e) {
                    addLog(`SourceBuffer init failed: ${e.message}`, 'error');
                    mediaSource.endOfStream();
                    mseInUse = false;
                    reject(e);
                    return;
                }

                const reader = response.body.getReader();
                const queue = [];
                let appending = false;
                let receivedBytes = 0;
                let receivedChunks = 0;

                sourceBuffer.addEventListener('updateend', () => {
                    appending = false;
                    if (queue.length > 0 && !sourceBuffer.updating) {
                        appending = true;
                        sourceBuffer.appendBuffer(queue.shift());
                    }
                });

                const pump = async () => {
                    try {
                        const { done, value } = await reader.read();
                        if (done) {
                            addLog('End of stream received from server.', 'success');
                            mediaSource.endOfStream();
                            resolve();
                            return;
                        }

                        receivedChunks++;
                        receivedBytes += value.length;
                        updateProgress(receivedBytes, receivedChunks);

                        const { hex, ascii, shown } = hexAsciiPreview(value, 64);
                        updateStreamingData(`Chunk ${receivedChunks}: ${value.length} bytes (showing ${shown})\n  HEX: ${hex}\n  ASCII: ${ascii}\n\n`);

                        const copy = createSafeCopy(value);
                        if (sourceBuffer.updating || appending) {
                            queue.push(copy);
                        } else {
                            appending = true;
                            sourceBuffer.appendBuffer(copy);
                        }

                        try { await audioPlayer.play(); } catch(_) {}
                        pump();
                    } catch (err) {
                        addLog(`Pump error: ${err.message}`, 'error');
                        try { mediaSource.endOfStream(); } catch(_) {}
                        reject(err);
                    }
                };

                pump();
            });

            mediaSource.addEventListener('sourceended', () => addLog('MediaSource ended.', 'info'));
            mediaSource.addEventListener('sourceclose', () => addLog('MediaSource closed.', 'info'));
        });
    }

    // ===== Fallback: buffer to Blob then play =====
    async function playStreamWithBlob(response, mimeType) {
        addLog(`Falling back to Blob buffering (no MSE support for ${mimeType}).`, 'warning');
        const reader = response.body.getReader();
        const chunks = [];
        let receivedBytes = 0;
        let receivedChunks = 0;

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            receivedChunks++;
            receivedBytes += value.length;
            updateProgress(receivedBytes, receivedChunks);

            const { hex, ascii, shown } = hexAsciiPreview(value, 64);
            updateStreamingData(`Chunk ${receivedChunks}: ${value.length} bytes (showing ${shown})\n  HEX: ${hex}\n  ASCII: ${ascii}\n\n`);

            chunks.push(value);
        }

        const blob = new Blob(chunks, { type: mimeType });
        const url = URL.createObjectURL(blob);
        audioPlayer.src = url;
        audioPlayer.style.display = 'block';
        try { await audioPlayer.play(); } catch(_) {}
    }

    // ===== Main handler =====
    generateBtn.addEventListener('click', async (e) => {
        e.preventDefault();

        // Validate form
        if (!document.getElementById('text').value.trim()) {
            addLog('Please enter some text to convert to speech.', 'error');
            return;
        }

        // Cancel previous stream if running
        if (currentAbort) {
            addLog('Aborting previous stream...', 'warning');
            currentAbort.abort();
        }

        // Get form data
        const formData = getFormData();
        const mimeType = getMimeType();

        // Reset UI
        totalBytes = 0; chunkCount = 0;
        streamingData.textContent = '';
        progressFill.style.width = '0%';
        bytesReceived.textContent = '0';
        chunksReceived.textContent = '0';
        timeElapsed.textContent = '0s';
        avgSpeed.textContent = '0';
        progressSection.style.display = 'block';
        streamingSection.style.display = 'block';
        audioPlayer.style.display = 'none';
        audioStatus.textContent = 'Starting streaming audio generation...';

        generateBtn.disabled = true;
        generateBtn.textContent = 'ðŸ”„ Streaming...';

        addLog('Sending streaming request to Spring Boot application...', 'info');
        addLog(`Request data: ${JSON.stringify(formData, null, 2)}`);
        updateStreamingData('--- STREAMING STARTED ---\n');

        startTime = Date.now();
        currentAbort = new AbortController();

        try {
            const response = await fetch('/api/tts/stream', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(formData),
                signal: currentAbort.signal
            });

            addLog(`Response status: ${response.status} ${response.statusText}`);
            if (!response.ok || !response.body) {
                const text = await response.text().catch(() => '');
                throw new Error(`HTTP ${response.status}: ${text || 'No body'}`);
            }

            // Choose playback path
            const mseSupported = ('MediaSource' in window) && MediaSource.isTypeSupported(mimeType);
            addLog(`MSE supported for ${mimeType}: ${mseSupported}`, mseSupported ? 'success' : 'warning');

            if (mseSupported) {
                await playStreamWithMSE(response, mimeType);
            } else {
                await playStreamWithBlob(response, mimeType);
            }

            addLog('Streaming completed!', 'success');
            updateStreamingData('--- STREAMING COMPLETED ---\n');
            audioStatus.textContent = 'Streaming audio generation completed!';

            try {
                await audioPlayer.play();
                addLog('Audio playing.', 'success');
            } catch {
                addLog('Auto-play blocked. Click play manually.', 'info');
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                addLog('Stream aborted by user action.', 'warning');
                updateStreamingData('--- STREAM ABORTED ---\n');
            } else {
                addLog(`Error: ${error.message}`, 'error');
                audioStatus.textContent = 'Error generating streaming audio. Check console for details.';
                updateStreamingData(`--- ERROR: ${error.message} ---\n`);
            }
        } finally {
            generateBtn.disabled = false;
            generateBtn.textContent = 'ðŸŽµ Generate Streaming Speech';
            currentAbort = null;
        }
    });

    // ===== Audio events with emojis =====
    audioPlayer.addEventListener('loadstart', () => addLog('â³ Audio loading started...'));
    audioPlayer.addEventListener('canplay', () => addLog('âœ… Audio can start playing', 'success'));
    audioPlayer.addEventListener('playing', () => addLog('ðŸŽµ Audio is playing', 'success'));
    audioPlayer.addEventListener('ended', () => addLog('ðŸ Audio playback finished'));
    audioPlayer.addEventListener('error', () => addLog(`âŒ Audio error: ${audioPlayer.error ? audioPlayer.error.message : 'Unknown error'}`, 'error'));
    audioPlayer.addEventListener('pause', () => addLog('â¸ï¸ Audio paused'));
    audioPlayer.addEventListener('volumechange', () => addLog('ðŸ”Š Volume changed'));
    audioPlayer.addEventListener('seeking', () => addLog('â© Seeking audio position'));
    audioPlayer.addEventListener('seeked', () => addLog('ðŸŽ¯ Audio seek completed'));
</script>
</body>
</html>